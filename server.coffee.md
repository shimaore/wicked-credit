TS stream muxer-demuxer
-----------------------

Problem statement:

Although `ffmpeg` may be used for a similar goal (using the `copy` codec), it only accepts to map ES that are available at startup time. This means in particular that subtitles are often not made available.

Analysis:

- TS Streams (such a made available by third parties or by `dvblast`) are transported as UDP multicast.
- A TS stream is made out of [TS packets](https://en.wikipedia.org/wiki/MPEG_transport_stream#Packet).
- Each TS packet carries the PID it is associated with; the PID identifies an ES within the TS.
- The PID's semantics are provided by the PMT.
- The [Elementary Stream Types](https://en.wikipedia.org/wiki/Program-specific_information#Elementary_stream_types) indicated by each PID are not sufficient to know the content of the stream.
- PMT's in broadcast media are relatively static and can be known in advance (e.g. from http://fr.kingofsat.fr/pos-13E.php, or dvblast output: `dvblastctl -r /tmp/dvblast-3-2.sock get_pmt 1031`).

Solution:

- We provide mapping of a TS UDP stream to one or multiple outbound streams.

Note that our solution supports:
- UDP unicast or multicast as source;
- UDP unicast or multicast as sink.

Configuration
-------------

```
{
"source": {
"protocol": "udp4",
"address":"239.200.5.2",
"port":2002,
"multicast": true
}
"sinks":[
{
"description":"Arte, audio allemand, sous-titres franÃ§ais",
"source": {
"protocol": "udp4",
"port": 10000,
"address": "10.1.1.1"
}
"multicast": true,
"address":"239.200.5.2",
"port":12002,
"pids":[320,333,340]
}
]
}
```

    dgram = require 'dgram'
    seem = require 'seem'
    {debug,hand} = (require 'tangible') 'wicked-credit:server'
    promisify = require './promisify'

The whole problem is made simple by the fact that TS packets have a static length and are aligned on UDP packet boundaries.
This means we do not have to do framing inside the UDP packets, and deducing the number of TS packets in a UDP packet is trivial.

    TS_PACKET_LENGTH = 188

Statistics

    received_udp = 0
    received_ts  = 0
    sent_udp = 0
    sent_ts = 0
    reporter = ->
      console.log """
        Received: #{received_udp} UDP, #{received_ts} TS. Sent: #{sent_udp} UDP, #{sent_ts} TS.
      """
    # setInterval reporter, 1000

Receiver
--------

The receiver is responsible for handling incoming UDP packets, and split them into individual TS packets.

    receiver = (opts) ->
      {protocol,port,address,multicast} = opts

Create the UDP socket, making sure the port and address we will use can be shared with other processes (typically ffmpeg).

      r = dgram.createSocket
        type: protocol ? 'udp4'
        reuseAddr: true

FIXME Should handle `error`, `listening`, etc.

### UDP packets receiver

      r.on 'message', (msg,rinfo) ->

Since TS packets have a fixed length, we split the UDP packet in TS-packet-length chunks.
(If the UDP packet length is not aligned on TS-packet-length boundaries we junk the last chunk.)

        nb_packets = Math.floor msg.length / TS_PACKET_LENGTH

Update statistics.

        received_udp++
        received_ts += nb_packets

Build the list of TS packets,

        ts_packets = [0...nb_packets].map (i) ->

slicing the original (received) buffer into TS-packet-lenght chunks,

          ts_packet = msg.slice i*TS_PACKET_LENGTH, (i+1)*TS_PACKET_LENGTH

reading the header of each TS packet

          header = ts_packet.readUInt32BE 0

in order to extract the ES' PID

          pid = (header & 0x001fff00) >> 8

and build a data structure to hold the PID and the TS packet.

          {pid,ts_packet}

For each received UDP packet we emit one message towards the sending side, with an array containing the series of `{pid,ts_packets}` from the input.

        r.emit 'ts_packets', ts_packets

        return

### Receiver startup

Asynchronously start the receiver,

      (do seem ->

binding it to the port and address
FIXME: exclusive is probably not needed

          yield promisify r, r.bind, {port, address, exclusive: false}

and if the source is marked `multicast`, make sure we register for membership on the destination address.

          r.addMembership address if multicast

If startup failed, exit the process.
FIXME: Should simply report the error if we allow for dynamically add/remove mappings.

      ).catch (error) ->
        console.error opts, error
        process.exit 1

Return the receiver.

      return r

Transcribe
----------

On the sending side, we handle events generated by the receiver, filtering on the PIDs we were told to monitor.

For each incoming UDP packet, we will send out a new UDP packet if data is available for at least one of the PIDs we are responsible for.

Note: we do not attempt to "optimize" things by packing multiple ES into a smaller number of UDP packets because:
- it would introduce jitter;
- video ES make up the bulk of content (audio, subtitles, PAT, PMT are much smaller), and in most cases we will have almost-full UDP packets.

    transcribe = (receiver,opts) ->
      {source,multicast,address,port,pids} = opts

Build a `Set` object in order to efficiently query the list of PIDs.

      my_pids = new Set pids

Create the outbound socket.

      t = dgram.createSocket source?.protocol ? 'udp4'

### Message handler

For each inbound UDP packet that was split into TS packets by the receiver,

      receiver.on 'ts_packets', (ts_packets) ->

our list of TS packets consists of
those TS packets whose PID are in our desired set

        my_packets = ts_packets
          .filter ({pid}) -> my_pids.has pid
          .map ({ts_packet}) -> ts_packet

If we have at least one TS packet to transmit,

        nb_packets = my_packets.length
        return unless nb_packets > 0

build the UDP packet by concatenating the TS packet in the order they were received,

        msg = Buffer.concat my_packets

and send the UDP packet out.
Note: this syntax is compatible with pre-5.5 Node.js, although one should probably not attempt to use such old versions in production.

        t.send msg, 0, nb_packets * TS_PACKET_LENGTH, port, address

Collect statistics.

        sent_udp++
        sent_ts += nb_packets

        return

### Startup

Asynchronously start the sender,

      (do seem ->

which only need to be bound if the information was provided.

        if source?

We first bind the socket to the (optional) port and (optional) address,

          args = []
          args.push source.port if source.port?
          args.push source.address if source.address?
          yield promisify t, t.bind, args... if args.length > 0

and if the destination is multicast, we request multicast access on the corresponding interface.
Note: older Node.js does not support `setMulticastInterface`, again one should probably not use those older versions.

          t.setMulticastInterface? source.address if multicast

If startup failed, exit the process.
FIXME: Should simply report the error if we allow for dynamically add/remove mappings.

      ).catch (error) ->
        console.error opts, error
        process.exit 1

      return

Main
----


    main = seem (configuration) ->

Start the receiver

      r = yield receiver configuration.source

and a sending process for each sink.

      configuration.sinks.forEach (opts) -> transcribe r, opts

Startup
-------

The configuration can be provided either as the program's parameter, or in the `CONFIG` environment variable.

    config_file = process.argv[2] ? process.env.CONFIG
    unless config_file?
      console.log "Usage:  #{process.argv[1]} config.json  , or provide CONFIG in environment."
      process.exit 1

The configuration might be inband, consisting of a JSON description,

    if config_file[0] is '{'
      config = JSON.parse config_file

or out of band, in which case we load it from the file location indicated.

    else
      config = require config_file

    debug 'Configuration', config_file, config

Start the main process with the configuration.

    main config
