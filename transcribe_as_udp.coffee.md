    dgram = require 'dgram'
    seem = require 'seem'
    {debug,hand,heal} = (require 'tangible') 'wicked-credit:transcribe_as_udp'
    promisify = require './promisify'
    {make_pat,make_pmt} = require './tools'

    TS_PACKET_LENGTH = 188

Transcribe as UDP
-----------------

On the sending side, we handle events generated by the receiver, filtering on the PIDs we were told to monitor.

For each incoming UDP packet, we will send out a new UDP packet if data is available for at least one of the PIDs we are responsible for.

Note: we do not attempt to "optimize" things by packing multiple ES into a smaller number of UDP packets because:
- it would introduce jitter;
- video ES make up the bulk of content (audio, subtitles, PAT, PMT are much smaller), and in most cases we will have almost-full UDP packets.

    module.exports =
    transcribe_as_udp = seem (receiver,opts) ->
      {source,multicast,address,port,pids} = opts

      debug 'Starting transcribe as UDP', opts

Build a `Set` object in order to efficiently query the list of PIDs.

      my_pids = new Set pids

Create the outbound socket.

      t = dgram.createSocket source?.protocol ? 'udp4'

### Message handler

      sent_udp = 0
      sent_ts = 0

      send = (packets) ->

        packets = packets.filter (x) -> x?

If we have at least one TS packet to transmit,

        nb_packets = packets.length
        return unless nb_packets > 0

build the UDP packet by concatenating the TS packet in the order they were received,

        msg = Buffer.concat packets

and send the UDP packet out.
Note: this syntax is compatible with pre-5.5 Node.js, although one should probably not attempt to use such old versions in production.

        t.send msg, 0, nb_packets * TS_PACKET_LENGTH, port, address

Collect statistics.

        sent_udp++
        sent_ts += nb_packets
        return

      pmt_pid = null
      last_opts = null

      pat_ctx = cc:0
      pmt_ctx = cc:0

      pat = -> if last_opts? then make_pat last_opts, pat_ctx else null
      pmt = -> if last_opts? then make_pmt pids, last_opts, pmt_ctx else null

Handle PMT indications
----------------------

      receiver.on 'pmt', (opts) ->
        {pmt_pid} = opts
        last_opts = opts
        return

For each inbound UDP packet that was split into TS packets by the receiver,

      last_ts_packet = null

      receiver.on 'ts_packets', (ts_packets) ->

our list of TS packets consists of
those TS packets whose PID are in our desired set

        send ts_packets.map (p) ->
          if last_ts_packet and p.received_ts isnt last_ts_packet + 1
            debug "Out of order #{p.received_ts - last_ts_packet+1}"
          last_ts_packet = p.received_ts

          {pid,pcr_pid} = p
          pkt = p.ts_packet
          switch
            when pid is 0
              pat()
            when pid is pmt_pid
              pmt()
            when my_pids.has pid
              pkt
            when pid is pcr_pid and opts.add_pcr
              pkt
            else
              null

        return

### Transcribe UDP: Startup

Asynchronously start the sender,
which only needs to be bound if the information was provided.

      if source?

We first bind the socket to the (optional) port and (optional) address,

        args = []
        args.push source.port if source.port?
        args.push source.address if source.address?
        yield promisify t, t.bind, args... if args.length > 0

and if the destination is multicast, we request multicast access on the corresponding interface.
Note: older Node.js do not support `setMulticastInterface`, again one should probably not use those older versions.

        t.setMulticastInterface? source.address if multicast

      return
